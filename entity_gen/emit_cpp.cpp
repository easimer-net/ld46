// === Copyright (c) 2020 easimer.net. All rights reserved. ===
//
// Purpose: entry point
//

#include "stdafx.h"
#include "common.h"
#include "parser.h"
#include "output.h"

char const* gpszHeader = "// AUTOGENERATED DO NOT MODIFY\n";

static void WriteHeaderInclude(IOutput* out, char const* pszFile) {
    out->Printf("#include %s\n", pszFile);
}

static void WriteHeaderInclude(IOutput* out, String const& pszFile) {
    out->Printf("#include %s\n", pszFile.c_str());
}

#define EMIT_INCLUDE(file) WriteHeaderInclude(out, file)

static String FieldToCField(Field_Definition const& field) {
    String ret = field.type.base;
    ret = ret + ' ' + field.name;
    if (field.type.count != 1) {
        ret = ret + '[' + std::to_string(field.type.count) + ']';
    }

    return ret;
}


void GenerateHeaderFile(IOutput* out, Vector<Table_Definition> const& tables) {
    assert(out != NULL);
    char const* apszIncludes[] = { "<cstdint>", "<vector>", "<unordered_map>", "<optional>",
        "<variant>", "<utils/linear_math.h>", "\"textures.h\"", "\"animator.h\"", "\"entity_gen.h\"" };
    constexpr auto unIncludesCount = sizeof(apszIncludes) / sizeof(apszIncludes[0]);
    out->Printf(gpszHeader);
    out->Printf("#pragma once\n");
    for (size_t i = 0; i < unIncludesCount; i++) EMIT_INCLUDE(apszIncludes[i]);
    out->Printf("\n");

    for (auto& table : tables) {
        // Emit constants first
        for (auto const& constant : table.constants) {
            out->Printf("#define %s %d\n", constant.name.c_str(), constant.value);
        }

        out->Printf("struct %s {\n", table.name.c_str());
        bool bHasTempField = false;
        for (auto& field : table.fields) {
            out->Printf("    %s;\n", FieldToCField(field).c_str());
            bHasTempField |= (field.flags & k_unFieldFlags_Reset) != 0;
        }

        if (bHasTempField) {
            out->Printf("    void ResetTransients() {\n");
            for (auto& field : table.fields) {
                if ((field.flags & k_unFieldFlags_Reset) != 0) {
                    out->Printf("        Reset(%s);\n", field.name.c_str());
                }
            }
            out->Printf("    }\n");
        }

        out->Printf("};\n\n");
    }

    out->Printf("struct Game_Data { \n    TABLE_COLLECTION();\n    Vector<Entity> entities;\n");

    for (auto& table : tables) {
        if (table.name != "Entity") {
            out->Printf("    ADD_TABLE(%s, %s);\n", table.var_name.c_str(), table.name.c_str());
        }
    }

    out->Printf(TAB "void Clear() { \n");
    for (auto& table : tables) {
        if (table.name != "Entity") {
            out->Printf(TAB2 "%s.clear();\n", table.var_name.c_str());
        } else {
            out->Printf(TAB2 "entities.clear();\n");
        }
    }
    out->Printf(TAB "}\n\n");

    out->Printf(TAB "void DeleteEntity(Entity_ID i) {\n");
    out->Printf(TAB2 "assert(i < entities.size());\n");
    for (auto& table : tables) {
        if (table.name != "Entity") {
            out->Printf(TAB2 "%s.erase(i);\n", table.var_name.c_str());
        }
    }
    out->Printf(TAB2 "entities[i].bUsed = false;\n");
    out->Printf(TAB "}\n");

    out->Printf("};\n");
}

static char const* gpszSaveLevelHeader = "\n\
void SaveLevel(char const* pszPath, Game_Data const& game_data) { \n\
    auto hFile = fopen(pszPath, \"wb\");                          \n\
    if(hFile != NULL) {                                           \n\
        defer([=]() { fclose(hFile); });                          \n\
        Level_Header hdr;                                         \n\
        fwrite(&hdr, sizeof(hdr), 1, hFile);                      \n\
";

static char const* gpszSaveLevelFooter = "\n\
    } else {                                            \n\
        printf(\"SaveLevel(%%s) failed!\\n\", pszPath);  \n\
    }                                                   \n\
}\n";

static char const* gpszLoadLevelHeader = "\n\
void LoadLevel(char const* pszPath, Game_Data& aGameData) { \n\
    auto hFile = fopen(pszPath, \"rb\");                    \n\
    if(hFile != NULL) {                                     \n\
        defer([=]() { fclose(hFile); });                    \n\
        Level_Header hdr;                                   \n\
        fread(&hdr, sizeof(hdr), 1, hFile);                 \n\
        if(!CheckHeader(hdr)) { return; }                   \n\
";

static char const* gpszLoadLevelFooter = "\n\
    } else {                                            \n\
        printf(\"LoadLevel(%%s) failed!\\n\", pszPath);  \n\
    }                                                   \n\
}\n";

static char const* gpszEntityWriteHeader = "\
        uint16_t const unEntityCount = CountEntities(game_data);    \n\
        fwrite(&unEntityCount, sizeof(unEntityCount), 1, hFile);    \n\
        for (Entity_ID i = 0; i < game_data.entities.size(); i++) { \n\
            auto const& ent = game_data.entities[i];                \n\
            Write(hFile, i);                                        \n\
";

static char const* gpszEntityWriteFooter = "\
        }\n";

static char const* gpszEntityReadHeader = "\
        uint16_t unEntityCount;                                     \n\
        fread(&unEntityCount, sizeof(unEntityCount), 1, hFile);     \n\
        for (unsigned i = 0; i < unEntityCount; i++) {              \n\
            Entity_ID iEnt;                                         \n\
            Read(hFile, &iEnt);                                     \n\
            auto& ent = AllocateEntity(aGameData, iEnt);            \n\
";

static char const* gpszEntityReadFooter = "\
        }\n";

static String GetChunkIdConstant(Table_Definition const& table) {
    String tableCapital = "CHUNKID_" + table.name;
    ToUpper(tableCapital);
    return tableCapital;
}

static void DefineSerializationConstants(IOutput* out, Vector<Table_Definition> const& tables) {
    uint16_t chunkId = 1;
    for (auto& table : tables) {
        if ((table.flags & k_unTableFlags_Memory_Only) == 0) {
            auto const tableCapital = GetChunkIdConstant(table);
            out->Printf("#define %s (%d)\n", tableCapital.c_str(), chunkId++);
        }
    }
}

static void EmitSaveLevel(IOutput* out, Vector<Table_Definition> const& tables) {
    out->Printf(gpszSaveLevelHeader);

    // Entity table is special
    for (auto& table : tables) {
        if (table.name == "Entity") {
            out->Printf(gpszEntityWriteHeader);
            for (auto& field : table.fields) {
                if ((field.flags & k_unFieldFlags_Memory_Only) == 0) {
                    out->Printf(TAB3 "Write(hFile, ent.%s);\n", field.name.c_str());
                }
            }
            out->Printf(gpszEntityWriteFooter);
            break;
        }
    }

    for (auto& table : tables) {
        if ((table.flags & k_unTableFlags_Memory_Only) == 0 && table.name != "Entity") {
            auto const tableCapital = GetChunkIdConstant(table);
            out->Printf(TAB2 "// Dump %s\n", table.var_name.c_str());
            out->Printf(TAB2 "BEGIN_SECTION_WRITE(%s, game_data.%s)\n",
                tableCapital.c_str(), table.var_name.c_str());
            out->Printf(TAB2 "for(auto& kv : game_data.%s) {\n",
                table.var_name.c_str());
            out->Printf(TAB3 "Write(hFile, kv.first);\n");
            for (auto& field : table.fields) {
                if ((field.flags & k_unFieldFlags_Memory_Only) == 0) {
                    if (field.type.count == 1) {
                        out->Printf(TAB3 "Write(hFile, kv.second.%s);\n", field.name.c_str());
                    } else {
                        auto const pszSizeConst = GenerateConstantIdentifier(table, field);
                        out->Printf(TAB3 "Write(hFile, %s, kv.second.%s);\n", pszSizeConst.c_str(), field.name.c_str());
                    }
                }
            }
            out->Printf(TAB2 "}\n");
            out->Printf(TAB2 "END_SECTION_WRITE()\n\n");
        }
    }

    out->Printf(gpszSaveLevelFooter);
}

static void EmitLoadLevel(IOutput* out, Vector<Table_Definition> const& tables) {
    out->Printf(gpszLoadLevelHeader);

    // Entity table is special
    for (auto& table : tables) {
        if (table.name == "Entity") {
            out->Printf(gpszEntityReadHeader);
            for (auto& field : table.fields) {
                if ((field.flags & k_unFieldFlags_Memory_Only) == 0) {
                    out->Printf(TAB3 "Read(hFile, &ent.%s);\n", field.name.c_str());
                }
            }
            out->Printf(gpszEntityReadFooter);
            break;
        }
    }

    out->Printf(TAB2 "while (!feof(hFile)) {\n");
    out->Printf(TAB3 "uint16_t uiChunkId, unCount;\n");
    out->Printf(TAB3 "Entity_ID iEnt;\n");
    out->Printf(TAB3 "fread(&uiChunkId, sizeof(uiChunkId), 1, hFile);\n");
    out->Printf(TAB3 "fread(&unCount, sizeof(unCount), 1, hFile);\n");
    out->Printf(TAB3 "for (unsigned i = 0; i < unCount; i++) {\n");
    out->Printf(TAB4 "Read(hFile, &iEnt);\n");
    out->Printf(TAB4 "switch(uiChunkId) {\n");
    for (auto& table : tables) {
        if (table.name != "Entity" && (table.flags & k_unTableFlags_Memory_Only) == 0) {
            auto const pszChunkId = GetChunkIdConstant(table);
            out->Printf(TAB4 "case %s:\n", pszChunkId.c_str());
            out->Printf(TAB4 "{\n");
            out->Printf(TAB5 "%s buf;\n", table.name.c_str());
            for (auto& field : table.fields) {
                if ((field.flags & k_unFieldFlags_Memory_Only) == 0) {
                    if (field.type.count == 1) {
                        out->Printf(TAB5 "Read(hFile, &buf.%s);\n", field.name.c_str());
                    } else {
                        auto const pszSizeConst = GenerateConstantIdentifier(table, field);
                        out->Printf(TAB5 "Read(hFile, %s, buf.%s);\n", pszSizeConst.c_str(), field.name.c_str());
                    }
                }
            }
            out->Printf(TAB5 "aGameData.%s[iEnt] = buf;\n", table.var_name.c_str());
            out->Printf(TAB5 "break;\n");
            out->Printf(TAB4 "}\n");
        }
    }
    out->Printf(TAB4 "}\n");
    out->Printf(TAB3 "}\n");
    out->Printf(TAB2 "}\n");

    out->Printf(gpszLoadLevelFooter);
}

void GenerateSerializationCode(IOutput* out, String const& pszGameName, Vector<Table_Definition> const& tables) {
    out->Printf(gpszHeader);
    out->Printf("#define SERIALIZATION_CPP\n");
    EMIT_INCLUDE('\"' + pszGameName + ".h\"");
    EMIT_INCLUDE("\"serialization_common.h\"");

    DefineSerializationConstants(out, tables);
    EmitSaveLevel(out, tables);
    EmitLoadLevel(out, tables);
}
